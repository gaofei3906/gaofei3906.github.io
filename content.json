{"meta":{"title":"我的博客","subtitle":null,"description":null,"author":"高立飞","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"apache设置代理访问nodejs","slug":"apache设置代理访问nodejs","date":"2018-12-02T12:04:34.000Z","updated":"2018-12-02T14:01:11.302Z","comments":false,"path":"2018/12/02/apache设置代理访问nodejs/","link":"","permalink":"http://yoursite.com/2018/12/02/apache设置代理访问nodejs/","excerpt":"","text":"1.修改apache配置文件httpd.conf配置文件，开启以下模块，去掉前面的#号即可：12LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_http_module modules/mod_proxy_http.so 2.设置域名：http://www.xxx.com代理nodejs的3000端口服务​ 修改虚拟主机配置文件：vhosts.conf 1234567891011&lt;VirtualHost *:80&gt; ServerName www.xxx.com ProxyRequests Off &lt;Proxy *&gt; Require all granted &lt;/Proxy&gt; &lt;Location /&gt; ProxyPass http://127.0.0.1:3000/ ProxyPassReverse http://127.0.0.1:3000/ &lt;/Location&gt;&lt;/VirtualHost&gt; 3.在电脑中设置hosts文件映射1127.0.0.1 api.vueshop.com 4.开启nodejs的3000端口服务12345678910var express = require('express');var app = express();app.get('/',function(req,res)&#123; res.end('代理成功');&#125;);app.listen(\"3000\",function()&#123; console.log(\"请访问 http://127.0.0.1:3000\");&#125;); 5.浏览器中输入http://www.xxx.com访问可以看到以下响应结果：1代理成功","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://yoursite.com/tags/apache/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"natappp_内网穿透","slug":"natappp-内网穿透","date":"2018-12-02T11:16:50.000Z","updated":"2018-12-02T11:28:08.232Z","comments":false,"path":"2018/12/02/natappp-内网穿透/","link":"","permalink":"http://yoursite.com/2018/12/02/natappp-内网穿透/","excerpt":"","text":"微信公众号开发者模式微信公众平台，可以在后台设置自动回复，但有时这个也满足不了我们的需求，可以开启开发模式，把公众号的消息回调到自己的服务器去处理。 微信公众平台提供了服务器接入的方式，具有开发能力的运营者，可以进行定制开发。 开发者模式：特别适合企业，所以我们说的微信公众号开发就是说开发者模式的学习与使用。 ==开发者模式需要一台外网能访问到的服务器== ==注意：==微信公众平台管理中，编辑模式和开发者模式是==互斥的==，也就是说只能使用其中一种。 开发者模式有2种请求方式： ==被动==： ==主动==： 准备工作实际的开发工作中，我们首先需要有一个外网服务器，比如 阿里云、腾讯云、百度云等；而对于我们当前学习测试阶段，我们可以换一种方案代替外网服务器：==内网穿透==。 内网穿透基本介绍natapp软件,它给我们提供一个外网的域名，通过此软件，把我们内网的IP和端口，映射到它自己的服务器上面，这样公众号服务器访问到他们的服务器上面，然后它在转发到我们的内网中，这样就实现了内网的穿透。 网址：https://natapp.cn/ 软件平台，需要注册，注册是免费不花钱的。可以免费使用，需要是成年人并且实名认证。 注册natapp 首先进入官网进行注册： 注册成功后进行需要进行实名认证： 点击后填写信息即可： 购买隧道 在后台界面点击：购买隧道–》免费隧道 填写信息，点击购买： 成功后查看： 列表中的==autotoken==是一个非常重要的信息，不要给别人，这就是我们进行内网穿透，的凭证，用此凭证，我们就可以知道其身份，所以不要乱给别人使用，会影响到自己的环境的使用。 本机配置 下载软件： 软件下载: https://natapp.cn/#download 将软件解压缩： 在解压后的文件夹中新建一个名为config.ini文件， 打开后构建如下配置内容： 在apache主配置文件httpd.conf中增加如下配置： 接着在apache的虚拟主机配置文件中增加如下配置： 重启apache， 测试访问项目文件： 在day1/code目录下创建一个info.php文件，内容如下： 然后在浏览器中访问： 访问成功！ 跟着进入natapp.exe所在目录，并且在当前目录下打开cmd黑窗口， 进入目录： 打开黑窗口： 在黑窗口中输入natapp后按回车： 输入： 回车后，出现如下界面；==注意：不要关闭下面的界面==： 使用远程地址替换本地地址进行测试访问： 访问成功，说明配置OK。 下载官方接入代码下载地址：http://t.cn/RkGPhCJ 下载后进行解压： 开启开发模式 首先进入后台 设置–》公众号设置 启用开发者密码（点击后将会要求填写相关认证信息）： 启用成功后界面效果为： 然后将官方接入程序文件拷贝一份到day1/code目录下，并且改名为wx.php 拷贝到day1/code下并改名： wx.php的内容： 继续在该界面点击修改配置，填写相关信息： 点击： 填写信息： 提交后再点击启用按钮启用开发者模式： 启用后界面效果为： 到此，开发模式就已经开启成功。 微信公众平台测试平台使用因为我们使用的订阅号和服务号没有认证，所以很多的接口没有提供给我们，这样在测试的阶段和开发的阶段就没有办法进行了，所以公众号考虑到开发者的此情况的存在，故提供了一个测试平台公众号，用此公众号来开发测试，可以有所有的权限，这样对我们的开发就没有障碍了。但是不包括支付接口。 测试平台登陆页面地址（需要扫码登陆）：https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 测试平台接入登陆平台后，填写接口配置信息并提交： ==注意：==上图中URL地址需要和 公众平台后台开发者模式设置的地址一致；Token也需要保持一致。 提交后提示成功界面效果如下说明接入测试平台成功： 接收普通消息 将day1/code/wx.php中的代码进行调整，构建测试代码： 我们当前使用的是PHP7.x，故将类wechatCallbackapiTest中reponseMsg方法里一句过时的代码改为可用的代码： 扫码关注测试公众号： 发送消息，查看测试公众号返回给用户的消息：","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"http://yoursite.com/tags/内网穿透/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"JS字符串常用方法","slug":"JavaScript字符串常用方法","date":"2018-12-02T05:39:03.000Z","updated":"2018-12-02T10:55:47.043Z","comments":false,"path":"2018/12/02/JavaScript字符串常用方法/","link":"","permalink":"http://yoursite.com/2018/12/02/JavaScript字符串常用方法/","excerpt":"","text":"JavaScript字符串常用方法字符串 字符串就是一个或多个排列在一起的字符，放在单引号或双引号之中。 12'abc'\"abc\" length属性js里的字符串类似于数组，都是一个一个字符拼凑在一起组成的，因此可以用length属性取得字符串的长度 12var str = \"hello\"str.length; // 5 字符串常用的一些方法1. charAt()1str.charAt(n) 作用： 返回字符串的第 n 个字符，如果不在 0~str.length-1之间，则返回一个空字符串。 123var str = \"javascript\";console.log( str.charAt(5) ); // 'c'console.log( str.charAt(15) ); // '' 2. indexOf()1indexOf(substr[,start]) 作用： 返回 substr 在字符串 str 中首次出现的位置,从 start 位置开始查找，如果不存在，则返回 -1。start可以是任意整数，默认值为 0。 1234var str = \"javascript\";console.log( str.indexOf('s') ); // 4console.log( str.indexOf('php',5) ); // -1console.log( str.indexOf('a',2) ); // 3 3. lastIndexOf()1lastIndexOf(substr[,start]) 作用： 返回 substr 在字符串 str 中最后出现的位置,从 start 位置 向前开始查找，如果不存在，则返回 -1。 12console.log( 'javascript'.lastIndexOf('a') ); // 3console.log( 'javascript'.lastIndexOf('o') ); // -1 4. substring()1str.substring(start[, end]) 作用：返回从 start 到 end（不包括）之间的字符，start、end均为 非负整数。若结束参数(end)省略，则表示从start位置一直截取到最后。 123var str = 'javascript';console.log( str.substring(1, 4) ); //\"ava\"console.log( str.substring(1) ); // \"avascript\" 5. slice()1str.slice(start[,end]) 作用：返回从 start 到 end （不包括）之间的字符，可传负值 1234var str = 'this is awesome';console.log( str.slice(1, 3) ); // \"hi\"console.log( str.slice(10, -1) ); // \"esom\"console.log( str.slice(10, -2) ); // \"eso\" 从最右边起，字母e为-1，m为-2,依次类推。 6. substr()1str.slice(start[,length]) 作用：返回 str 中从指定位置开始到指定长度的子字符串，start可为负值 123var str = \"javascript\";console.log( str.substr(5, 3) ); // \"cri\"console.log( str.substr(-4, 2) ); // \"ri\" 7. replace()1str.replace(regexp|substr, newSubStr|function) 作用：替换 str 的子字符串 123456789101112131415161718192021222324//普通替换var str = \"i love you\";console.log( str.replace('love','hate') ); // \"i hate you\"//正则替换var tel = '13534566789'; var reg = /(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)/g;console.log( tel.replace(reg,\"$1****$2\") ); // 135****6789//驼峰转换function strCovert(css)&#123; //定义一个正则尽可能找到我们要替换的内容 var reg = /-([a-z])/g; var newStr = css.replace(reg,function($0,$1)&#123; //$0:代表正则匹配的结果 //$1:代表正则匹配的第1个括号中的结果 console.log('$0:',$0); // -b -c console.log('$1:',$1); // b c return $1.toUpperCase(); &#125;); return newStr; &#125;var css = 'border-bottom-color'; console.log(strCovert(css)); //\"borderBottomColor\" 8. search()1str.search(regexp) 作用： 查找 str 与一个正则表达式是否匹配。如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引,否则返回 -1。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象 12345var str = 'I love JavaScript!';console.log( str.search(/java/) ); // -1console.log( str.search(/Java/) ); // 7console.log( str.search(/java/i) ); // 7console.log( str.search('Java') ); // 7 9. match()1str.match(regexp) 作用：返回一个包含匹配结果的数组，如果没有匹配项，则返回 null。如果参数传入的是一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象 12345var str = 'Javascript java';console.log( str.match(/Java/) ); // [\"Java\"]console.log( str.match(/Java/g) ); // [\"Java\"]console.log( str.match(/Java/gi) ); // [\"java\", \"Java\"]console.log( str.match(/ab/g) ); // null 10. split()1str.split([delimiter][, limit]) 作用：返回一个数组，分隔符delimiter 可以是一个字符串或正则表达式 123456var str = \"Hello?World!\";console.log( str .split() ); // [\"Hello?World!\"]console.log( str.split('?') ); // [\"Hello\", \"World!\"]console.log( str.split('') ); // [\"H\", \"e\", \"l\", \"l\", \"o\", \"?\", \"W\", \"o\", \"r\", \"l\", \"d\", \"!\"]console.log( str.split('',5) ); // [\"H\", \"e\", \"l\", \"l\", \"o\"]console.log( str.split(/\\?/) ); // [\"Hello\", \"World!\"] 11. trim()1str.trim() 作用：去除 str 开头和结尾处的空白字符，返回 str 的一个副本，不影响字符串本身的值 123var str = ' a b c ';console.log( str.trim() ); // 'a b c'console.log( str ); // ' abc ' 12. toLowerCase()1str.toLowerCase() 作用：将 str 转换为小写，并返回 str 的一个副本，不影响字符串本身的值 123var str = 'JavaScript';console.log( str.toLowerCase() ); // 'javascript'console.log(str); // 'JavaScript' 13. toUpperCase()1str.toUpperCase() 作用： 将 str 转换为大写，并返回 str 的一个副本，不影响字符串本身的值 123var str = 'JavaScript';console.log( str.toUpperCase() ); // 'JAVASCRIPT'console.log(str); // 'JavaScript' 14.repeat()1str.repeat(length) 作用：重复一个str字符串length次 12console.log( '*'.repeat(3) ); //***console.log( 'php'.repeat(3) ); //phpphpphp 15.concat()1str.concat(value，...) 作用：将value与字符串str拼接在一起 12var str = 'JavaScript';console.log( str.concat('php','mysql') ); // JavaScriptphpmysql","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"js字符串","slug":"js字符串","permalink":"http://yoursite.com/tags/js字符串/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"JS数组常用方法","slug":"JavaScript数组常用方法","date":"2018-12-02T05:39:03.000Z","updated":"2018-12-02T10:50:53.391Z","comments":false,"path":"2018/12/02/JavaScript数组常用方法/","link":"","permalink":"http://yoursite.com/2018/12/02/JavaScript数组常用方法/","excerpt":"","text":"JavaScript数组常用方法数组 所谓数组，就是一堆数据的集合（容器），里面存放各种各样的数据。 1var arr = ['a','b','c']; length属性可以用length属性取得数组(集合)的长度 12var arr = ['a','b','c'];arr.length; // 3 返回3，说明数组有三个元素 数组下标 数组中每个元素都有对应的标号指向它，这个标号我们可以称之为下标 下标从0开始，数组中的第1个元素下标为0，第2个元素下标为1，依次类推。 1234var arr = ['a','b','c'];arr[0]; // 'a'arr[1]; // 'b'arr[2]; // 'c' 当通过不存在的下标获取值则得到一个undefined值。 12var arr = ['a','b','c'];arr[4]; // undefined join()1arr.join(separator) 作用：把数组中的每个元素用分隔符separator进行连接起来，返回一个字符串。如果省略了这个参数，默认使用逗号作为分隔符 1234var arr = ['a','b','c'];console.log( arr.join('-') ); // 'a-b-c'console.log( arr.join('') ); // 'abc'console.log( arr.join() ); // 'a,b,c' pop()1arr.pop() 作用： 将删除arr的最后一个元素，把数组长度减1，并且返回它删除的元素的值。如果数组已经为空，则pop()不改变数组，返回undefined。 123456var arr = ['a','b','c'];console.log( arr.pop() ); // cconsole.log( arr.pop() ); // bconsole.log( arr.pop() ); // aconsole.log( arr.pop() ); // undefined push()1arr.push(value,...) 作用：向数组尾部添加一个或多个元素 ，成功返回数组的新长度 1234var arr = ['a','b','c'];console.log( arr.push('d') ); // 4console.log( arr.push('e','f') ); // 6console.log(arr); //[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] unshift()1arr.unshift(value,...) 作用：向数组头部添加一个或多个元素 ，成功返回数组的新长度。 1234var arr = ['a','b','c'];console.log( arr.unshift('d') ); // 4console.log( arr.unshift('e','f') ); // 6console.log(arr); // [\"e\", \"f\", \"d\", \"a\", \"b\", \"c\"] shift()1arr.shift() 作用：方法shift()将把arr的第—个元素移出数组，b并返回那个元素的值，并且将余下的所有元素前移一位，以填补数组头部的空缺 。 123var arr = ['a','b','c'];console.log( arr.shift('d') ); // 'a'console.log(arr); // [\"b\", \"c\"] sort()1arr.sort(callback) 作用：对数组进行排序，指定d回调函数callback进行排序。 返回值：对数组的引用。注意，数组在原数组上进行排序，不制作副本。 1234567891011var arr = [14,8,24];arr.sort( function(a,b)&#123; return a-b; // 或return a&gt;b &#125;) ; console.log(arr); // [8, 14, 24] 升序var arr = [14,8,24];arr.sort(function(a,b)&#123; return b-a; // 或return b&gt;a &#125;) ; console.log(arr); //[24, 14, 8] 降序 slice()1arr.slice(start,[,end]) 作用：截取数组长度。从下标start开始，到end（不包括该元素）下标结束， 12var arr = [1,2,3,4,5];console.log( arr.slice(2,4)); // [3,4] 若没有写end结束下标，则截取到数组末尾。 12var arr = [1,2,3,4,5];console.log( arr.slice(2)); // [3,4,5] 若end为负数，则从数组尾部开始截取，即-1指最后一个元素，-2指倒数第二个元素，以此类推 。 注：不包括最后一个元素。 123var arr = [1,2,3,4,5];console.log( arr.slice(2,-1)); // [3,4]console.log( arr.slice(2,-2)); // [3] toString()1arr.toString() 作用： 把数组转为用逗号连接的字符串表示。类似arr.join()效果一样 123var arr = [1,2,3,4,5];console.log( arr.toString() ); // '1,2,3,4,5'console.log( arr.join() ); // '1,2,3,4,5' splice()1arr.splice(start, deleteCount, value, ...) 参数 start 开始插入和(或)删除的数组元素的下标 deleteCount 从start开始，包括start所指的元素在内要删除的元素个数。这个参数是可选的，如果没有指定它，splice()将删除从start开始到原数组结尾的所有元素。 value 要插人数组的零个或多个值，从start所指的下标处开始插入 返回值 ​ 如果从arr中删除了元素，返回的是含有被删除的元素的数组。 例1：从下标2开始删除后面所有的元素 123var arr = [1,2,3,4,5];console.log( arr.splice(2) ); // [3,4,5]console.log(arr);// [1,2] 例2：从下标2开始删除后面的2个元素 123var arr = [1,2,3,4,5];console.log( arr.splice(2,2) ); // [3,4]console.log(arr);// [1,2,5] 例3：从下标2开始删除后面的2个元素,同时在start指定的下标2后面加一个元素new 123var arr = [1,2,3,4,5];console.log( arr.splice(2,2,'new') ); // [3,4]console.log(arr);// [1,2,'new',5] reverse()1arr.reverse() 作用：颠倒数组中元素的顺序,返回新的电刀后的数组元素 12var arr = [1,2,3,4,5];console.log( arr.reverse() ); // [5, 4, 3, 2, 1] isArray()作用：检测一个变量是否是数组。（typeof不行,返回的是object） 1234567function isArray(value)&#123; return Object.prototype.toString.call(value) == '[object Array]';&#125;var arr = [1,2,3,4,5];console.log(isArray(arr)); // trueconsole.log(isArray(&#123;&#125;)); // false 同理： ​ 判断是否是对象使用[object object] ​ 是否是字符串 [object string] ​ 以此类推 concat()作用：连接多个数组，返回新的数组 123var arr1 = [1,2,3,4,5];var arr2 = [6,7,8];console.log( arr1.concat(arr2) ); // [1, 2, 3, 4, 5, 6, 7, 8] foreach()作用：遍历数组元素 12345var arr = ['a','b','c'];arr.forEach(function(v,key)&#123; //v当前循环的元素 key当前元素的下标 console.log(key,v)&#125;); 结果： 1230 &quot;a&quot;1 &quot;b&quot;2 &quot;c&quot; filter()作用：过滤数组中的某些元素，在回调函数中设置条件，不满足的都会被过滤掉，返回一个新数组。 12345678var age = [18,23,28,30];var newArr = age.filter(function(v)&#123; //v当前循环的元素 //返回年龄大于25的元素 return v&gt;25;&#125;);console.log(newArr);// [28, 30] map()作用：遍历数组，数组里的元素经过指定回调函数进行加工处理。 返回一个新的数组 123456var age = [18,23,28,30];var newArr = age.map(function(v)&#123; //给每个元素加10岁 return v+10;&#125;);console.log(newArr); // [28, 33, 38, 40] reduce()reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。需要注意的是，reduce方法返回值并不是数组，而是返回经过叠加处理后的结果。 reduce方法最常见的场景就是叠加 123456789var items = [5,6,7];var callback = function(sum,item)&#123; //item数组值的每个元素 //sum每次累加的和 return sum+item;&#125;var total = items.reduce(callback,0); //把循环完后的累加结果加0console.log(total); // 18 数组去重方式有很多种。 用es6的Set对象 1234var arr = [1,2,3,3,4,5,5];var set = new Set(arr);var newArr = Array.from(set);console.log(newArr); // [1, 2, 3, 4, 5] 更骚气的用法： 12var newArr = [...new Set([1,2,3,3,4,5,5])]console.log(newArr); // [1, 2, 3, 4, 5] 另indexOf方法来判断，存在返回元素下标，不存在返回-1 建立一个存放结果的数组，利用indexOf判断是否存在于新数组中，不存在则push到新数组，最后返回新数组 1234567891011var unique = function(arr) &#123; var n = []; // 存放已遍历的满足条件的元素 for (var i = 0; i &lt; arr.length; i++) &#123; // indexOf()判断当前元素是否已存在 if (n.indexOf(arr[i]) == -1) n.push(arr[i]); &#125; return n;&#125;var arr = [1,2,2,3,3,4,5];console.log( unique(arr) ); // [1, 2, 3, 4, 5] 如果想arr.unique()这样调用，则需要把此方法加上Array的原型对象上。 12345678910Array.prototype.unique = function() &#123; var n = []; // 存放已遍历的满足条件的元素 for (var i = 0; i &lt; this.length; i++) &#123; // indexOf()判断当前元素是否已存在 if (n.indexOf(this[i]) == -1) n.push(this[i]); &#125; return n;&#125;var arr = [1,2,3,3,6,6];console.log( arr.unique() ); // [1, 2, 3, 6] 数组中是否存在于某个值可以用indexOf方法来判断，存在返回元素下标，不存在返回-1 123456function inArray(value,arr)&#123; return arr.indexOf(value)!== -1 ? true : false;&#125;var arr = [1,2,3];console.log( inArray(2,arr) ); // trueconsole.log( inArray(4,arr) ); // false","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"js数组","slug":"js数组","permalink":"http://yoursite.com/tags/js数组/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]}]}